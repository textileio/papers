

@article{bernersLee_readwrite_2013,
	title = {The read–write {Linked} {Data} {Web}},
	volume = {371},
	url = {https://royalsocietypublishing.org/doi/full/10.1098/rsta.2012.0513},
	doi = {10.1098/rsta.2012.0513},
	abstract = {This paper discusses issues that will affect the future development of the Web, either increasing its power and utility, or alternatively suppressing its development. It argues for the importance of the continued development of the Linked Data Web, and describes the use of linked open data as an important component of that. Second, the paper defends the Web as a read–write medium, and goes on to consider how the read–write Linked Data Web could be achieved.},
	number = {1987},
	urldate = {2019-09-23},
	journal = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {Berners-Lee, Tim and O’Hara, Kieron},
	month = mar,
	year = {2013},
	pages = {20120513}
}

@article{de_montjoye_trusted_2012,
	title = {On the {Trusted} {Use} of {Large}-{Scale} {Personal} {Data}.},
	volume = {35},
	number = {4},
	journal = {IEEE Data Eng. Bull.},
	author = {de Montjoye, Yves-Alexandre and Wang, Samuel S. and Pentland, Alex and Anh, Dinh Tien Tuan and Datta, Anwitaman},
	year = {2012},
	pages = {5--8}
}

@book{sambraSolidPlatformDecentralized2016,
  title = {Solid: {{A Platform}} for {{Decentralized Social Applications Based}} on {{Linked Data}}},
  url = {http://emansour.com/research/lusail/solid_protocols.pdf},
  shorttitle = {Solid},
  date = {2016},
  author = {Sambra, Andrei Vlad and Mansour, Essam and Hawke, Sandro and Zereba, Maged and Greco, Nicola and Ghanem, Abdurrahman and Zagidulin, Dmitri and Aboulnaga, Ashraf and Berners-Lee, Tim},
  file = {/Users/carsonfarmer/Zotero/storage/WRS7243G/Sambra et al. - 2016 - Solid A Platform for Decentralized Social Applica.pdf}
}

@article{schneiderImplementingFaulttolerantServices1990,
  title = {Implementing Fault-Tolerant Services Using the State Machine Approach: {{A}} Tutorial},
  volume = {22},
  shorttitle = {Implementing Fault-Tolerant Services Using the State Machine Approach},
  number = {4},
  journaltitle = {ACM Computing Surveys (CSUR)},
  date = {1990},
  pages = {299--319},
  author = {Schneider, Fred B.},
  file = {/Users/carsonfarmer/Zotero/storage/53HMRXP7/Schneider - 1990 - Implementing fault-tolerant services using the sta.pdf}
}

@online{dixonWhyDecentralizationMatters2018,
  langid = {english},
  title = {Why {{Decentralization Matters}}},
  url = {https://medium.com/s/story/why-decentralization-matters-5e3f79f7638e},
  abstract = {We’ve forgotten there’s a better way to build internet services},
  journaltitle = {Medium},
  urldate = {2019-09-19},
  date = {2018-10-26},
  author = {Dixon, Chris},
  file = {/Users/carsonfarmer/Zotero/storage/AMCES5LY/why-decentralization-matters-5e3f79f7638e.html}
}

@online{jaykrepsLogWhatEvery2013,
  langid = {english},
  title = {The {{Log}}: {{What}} Every Software Engineer Should Know about Real-Time Data's Unifying Abstraction},
  url = {https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying},
  shorttitle = {The {{Log}}},
  abstract = {I joined LinkedIn about six years ago at a particularly interesting time. We were just beginning to run up against the limits of our monolithic, centralized database and needed to start the transition to a portfolio of specialized distributed systems. This has been an interesting experience: we buil},
  urldate = {2019-09-19},
  date = {2013-12-16},
  author = {{Jay Kreps}},
  file = {/Users/carsonfarmer/Zotero/storage/3FV6CNMW/log-what-every-software-engineer-should-know-about-real-time-datas-unifying.html}
}

@book{bettsExploringCQRSEvent2013,
  title = {Exploring {{CQRS}} and {{Event Sourcing}}: {{A Journey}} into {{High Scalability}}, {{Availability}}, and {{Maintainability}} with {{Windows Azure}}},
  edition = {1st},
  isbn = {978-1-62114-016-0},
  shorttitle = {Exploring {{CQRS}} and {{Event Sourcing}}},
  abstract = {This guide is focused on building highly scalable, highly available, and maintainable applications with the Command \& Query Responsibility Segregation and the Event Sourcing architectural patterns. It presents a learning journey, not definitive guidance. It describes the experiences of a development team with no prior CQRS proficiency in building, deploying (to Windows Azure), and maintaining a sample real-world, complex, enterprise system to showcase various CQRS and ES concepts, challenges, and techniques. The development team did not work in isolation; we actively sought input from industry experts and from a wide group of advisors to ensure that the guidance is both detailed and practical. The CQRS pattern and event sourcing are not mere simplistic solutions to the problems associated with large-scale, distributed systems. By providing you with both a working application and written guidance, we expect youll be well prepared to embark on your own CQRS journey.},
  publisher = {{Microsoft patterns \& practices}},
  date = {2013},
  author = {Betts, Dominic and Dominguez, Julian and Melnik, Grigori and Simonazzi, Fernando and Subramanian, Mani}
}

@online{EventStore,
  title = {Event {{Store}}},
  url = {https://eventstore.org/},
  urldate = {2019-09-19},
  file = {/Users/carsonfarmer/Zotero/storage/G93L59TD/eventstore.org.html}
}

@online{ApacheKafka,
  langid = {english},
  title = {Apache {{Kafka}}},
  url = {https://kafka.apache.org/},
  abstract = {Apache Kafka: A Distributed Streaming Platform.},
  urldate = {2019-09-19},
  file = {/Users/carsonfarmer/Zotero/storage/I2J6VFHY/kafka.apache.org.html}
}

@online{ApacheSamza,
  title = {Apache {{Samza}}},
  url = {http://samza.apache.org/},
  urldate = {2019-09-19},
  file = {/Users/carsonfarmer/Zotero/storage/SI8HKDCA/samza.apache.org.html}
}

@book{kleppmannDesigningDataintensiveApplications2017,
  title = {Designing Data-Intensive Applications: {{The}} Big Ideas behind Reliable, Scalable, and Maintainable Systems},
  shorttitle = {Designing Data-Intensive Applications},
  publisher = {{" O'Reilly Media, Inc."}},
  date = {2017},
  author = {Kleppmann, Martin},
  file = {/Users/carsonfarmer/Zotero/storage/URFG4WXM/Kleppmann - 2017 - Designing data-intensive applications The big ide.pdf;/Users/carsonfarmer/Zotero/storage/VBNSTW5Z/books.html}
}

@online{fowlerEventSourcing,
  title = {Event {{Sourcing}}},
  url = {https://martinfowler.com/eaaDev/EventSourcing.html},
  abstract = {Capture all changes to an application state as a sequence of events.},
  journaltitle = {martinfowler.com},
  urldate = {2019-09-19},
  author = {Fowler, Martin},
  file = {/Users/carsonfarmer/Zotero/storage/E5N2GKVJ/EventSourcing.html}
}

@online{microsoftcorporationAzureApplicationArchitecture,
  langid = {american},
  title = {Azure {{Application Architecture Guide}}},
  url = {https://docs.microsoft.com/en-us/azure/architecture/guide/},
  abstract = {A structured approach for designing applications on Azure that are scalable, resilient, and highly available},
  journaltitle = {Microsoft Docs},
  type = {Guide},
  urldate = {2019-09-19},
  author = {{Microsoft Corporation}},
  file = {/Users/carsonfarmer/Zotero/storage/ECPGU2YM/guide.html}
}

@online{eventsourceEventSourcingBasics,
  title = {Event {{Sourcing Basics}}},
  url = {https://eventstore.org/docs/event-sourcing-basics/},
  type = {Docs},
  urldate = {2019-09-19},
  author = {{Event Source}},
  file = {/Users/carsonfarmer/Zotero/storage/SW7D5NXN/event-sourcing-basics.html}
}

@online{reduxReducers,
  langid = {english},
  title = {Reducers},
  url = {https://redux.js.org/},
  abstract = {Reducers},
  journaltitle = {Redux},
  urldate = {2019-09-19},
  author = {{Redux}},
  file = {/Users/carsonfarmer/Zotero/storage/5Y8B5HZG/reducers.html}
}

@online{reduxGettingStartedRedux,
  langid = {english},
  title = {Getting {{Started}} with {{Redux}}},
  url = {https://redux.js.org/},
  abstract = {\# Getting Started with Redux},
  journaltitle = {redux.js.org},
  type = {Software},
  urldate = {2019-09-19},
  author = {{Redux}},
  file = {/Users/carsonfarmer/Zotero/storage/SE4R7PXJ/getting-started.html}
}

@article{gilbertBrewerConjectureFeasibility2002a,
  title = {Brewer's Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services},
  volume = {33},
  number = {2},
  journaltitle = {Acm Sigact News},
  date = {2002},
  pages = {51--59},
  author = {Gilbert, Seth and Lynch, Nancy},
  file = {/Users/carsonfarmer/Zotero/storage/AYA2HMXZ/Gilbert and Lynch - 2002 - Brewer's conjecture and the feasibility of consist.pdf}
}

@inproceedings{brewerRobustDistributedSystems2000,
  title = {Towards {{Robust Distributed Systems}}},
  url = {http://pld.cs.luc.edu/courses/353/spr11/notes/brewer_keynote.pdf},
  eventtitle = {Invited {{Talk}}},
  booktitle = {19th {{ACM Symposium}} on {{Principles}} of {{Distributed Computing}} ({{PODC}})},
  date = {2000},
  author = {Brewer, Eric}
}

@article{almeidaDeltaStateReplicated2018,
  langid = {english},
  title = {Delta State Replicated Data Types},
  volume = {111},
  issn = {07437315},
  doi = {10.1016/j.jpdc.2017.08.003},
  journaltitle = {Journal of Parallel and Distributed Computing},
  shortjournal = {Journal of Parallel and Distributed Computing},
  date = {2018-01},
  pages = {162-173},
  author = {Almeida, Paulo Sérgio and Shoker, Ali and Baquero, Carlos},
  file = {/Users/carsonfarmer/Zotero/storage/SPTIUTW7/Almeida et al. - 2018 - Delta state replicated data types.pdf}
}

@article{parkerDetectionMutualInconsistency1983,
  title = {Detection of {{Mutual Inconsistency}} in {{Distributed Systems}}},
  volume = {SE-9},
  doi = {10.1109/TSE.1983.236733},
  abstract = {Many distributed systems are now being developed to provide users with convenient access to data via some kind of communications network. In many cases it is desirable to keep the system functioning even when it is partitioned by network failures. A serious problem in this context is how one can support redundant copies of resources such as files (for the sake of reliability) while simultaneously monitoring their mutual consistency (the equality of multiple copies). This is difficult since network faiures can lead to inconsistency, and disrupt attempts at maintaining consistency. In fact, even the detection of inconsistent copies is a nontrivial problem. Naive methods either 1) compare the multiple copies entirely or 2) perform simple tests which will diagnose some consistent copies as inconsistent. Here a new approach, involving version vectors and origin points, is presented and shown to detect single file, multiple copy mutual inconsistency effectively. The approach has been used in the design of LOCUS, a local network operating system at UCLA.},
  number = {3},
  journaltitle = {IEEE Transactions on Software Engineering},
  date = {1983-05},
  pages = {240-247},
  keywords = {Availability,Communication networks,Computer crashes,Computer science,Condition monitoring,Context,distributed systems,Maintenance,mutual consistency,network failures,Network operating systems,network partitioning,Performance evaluation,replicated data,Telecommunication network reliability,Testing},
  author = {Parker, D. S. and Popek, G. J. and Rudisin, G. and Stoughton, A. and Walker, B. J. and Walton, E. and Chow, J. M. and Edwards, D. and Kiser, S. and Kline, C.},
  file = {/Users/carsonfarmer/Zotero/storage/E3ARMDGL/1703051.html}
}

@report{shapiroComprehensiveStudyConvergent2011a,
  langid = {english},
  title = {A Comprehensive Study of {{Convergent}} and {{Commutative Replicated Data Types}}},
  url = {https://hal.inria.fr/inria-00555588},
  abstract = {Eventual consistency aims to ensure that replicas of some mutable shared object converge without foreground synchronisation. Previous approaches to eventual consistency are ad-hoc and error-prone. We study a principled approach: to base the design of shared data types on some simple formal conditions that are sufficient to guarantee eventual consistency. We call these types Convergent or Commutative Replicated Data Types (CRDTs). This paper formalises asynchronous object replication, either state based or operation based, and provides a sufficient condition appropriate for each case. It describes several useful CRDTs, including container data types supporting both \textbackslash{}add and \textbackslash{}remove operations with clean semantics, and more complex types such as graphs, montonic DAGs, and sequences. It discusses some properties needed to implement non-trivial CRDTs.},
  type = {report},
  urldate = {2019-09-19},
  date = {2011-01-13},
  author = {Shapiro, Marc and Preguiça, Nuno and Baquero, Carlos and Zawirski, Marek},
  file = {/Users/carsonfarmer/Zotero/storage/Y2RVPCXE/Shapiro et al. - 2011 - A comprehensive study of Convergent and Commutativ.pdf;/Users/carsonfarmer/Zotero/storage/MCQLQFZB/inria-00555588.html}
}

@incollection{kulkarniLogicalPhysicalClocks2014,
  location = {{Cham}},
  title = {Logical {{Physical Clocks}}},
  volume = {8878},
  isbn = {978-3-319-14471-9 978-3-319-14472-6},
  url = {http://link.springer.com/10.1007/978-3-319-14472-6_2},
  booktitle = {Principles of {{Distributed Systems}}},
  publisher = {{Springer International Publishing}},
  urldate = {2019-09-19},
  date = {2014},
  pages = {17-32},
  author = {Kulkarni, Sandeep S. and Demirbas, Murat and Madappa, Deepak and Avva, Bharadwaj and Leone, Marcelo},
  editor = {Aguilera, Marcos K. and Querzoni, Leonardo and Shapiro, Marc},
  doi = {10.1007/978-3-319-14472-6_2}
}

@article{schwarzDetectingCausalRelationships1994,
  langid = {english},
  title = {Detecting Causal Relationships in Distributed Computations: {{In}} Search of the Holy Grail},
  volume = {7},
  issn = {0178-2770, 1432-0452},
  doi = {10.1007/BF02277859},
  shorttitle = {Detecting Causal Relationships in Distributed Computations},
  number = {3},
  journaltitle = {Distributed Computing},
  shortjournal = {Distrib Comput},
  date = {1994-03},
  pages = {149-174},
  author = {Schwarz, Reinhard and Mattern, Friedemann},
  file = {/Users/carsonfarmer/Zotero/storage/M2D7HW4V/Schwarz and Mattern - 1994 - Detecting causal relationships in distributed comp.pdf}
}

@article{katzInterleavingSetTemporal1990,
  title = {Interleaving Set Temporal Logic},
  volume = {75},
  number = {3},
  journaltitle = {Theoretical Computer Science},
  date = {1990},
  pages = {263--287},
  author = {Katz, Shmuel and Peled, Doron},
  file = {/Users/carsonfarmer/Zotero/storage/FLFL9VRM/030439759090096Z.html}
}

@article{lamportTimeClocksOrdering1978,
  title = {Time, Clocks, and the Ordering of Events in a Distributed System},
  volume = {21},
  issn = {00010782},
  doi = {10.1145/359545.359563},
  number = {7},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  date = {1978-07-01},
  pages = {558-565},
  author = {Lamport, Leslie},
  file = {/Users/carsonfarmer/Zotero/storage/BEG6DK2R/Lamport - 1978 - Time, clocks, and the ordering of events in a dist.pdf}
}

@article{ramabajaBloomClock2019,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1905.13064},
  primaryClass = {cs},
  title = {The {{Bloom Clock}}},
  url = {http://arxiv.org/abs/1905.13064},
  abstract = {The bloom clock is a space-efficient, probabilistic data structure designed to determine the partial order of events in highly distributed systems. The bloom clock, like the vector clock, can autonomously detect causality violations by comparing its logical timestamps. Unlike the vector clock, the space complexity of the bloom clock does not depend on the number of nodes in a system. Instead it depends on a set of chosen parameters that determine its confidence interval, i.e. false positive rate. To reduce the space complexity from which the vector clock suffers, the bloom clock uses a 'moving window' in which the partial order of events can be inferred with high confidence. If two clocks are not comparable, the bloom clock can always deduce it, i.e. false negatives are not possible. If two clocks are comparable, the bloom clock can calculate the confidence of that statement, i.e. it can compute the false positive rate between comparable pairs of clocks. By choosing an acceptable threshold for the false positive rate, the bloom clock can properly compare the order of its timestamps, with that of other nodes in a highly accurate and space efficient way.},
  urldate = {2019-09-19},
  date = {2019-05-30},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Distributed; Parallel; and Cluster Computing},
  author = {Ramabaja, Lum},
  file = {/Users/carsonfarmer/Zotero/storage/8SFQAQ7W/Ramabaja - 2019 - The Bloom Clock.pdf;/Users/carsonfarmer/Zotero/storage/BX6BA8EK/1905.html}
}

@unpublished{sanjuanMerkleCRDTs2019,
  langid = {english},
  title = {Merkle-{{CRDTs}}},
  abstract = {Merkle-DAG-backed CRDTs have been used to build some distributed applications on top of the Interplanetary File System (IPFS). In this paper we study Merkle-DAGs as transport and persistence layer for CRDT data types, coining the term Merkle-CRDTs and providing an overview of the diﬀerent concepts, properties, advantages and limitations involved. We show how Merkle-CRDTs have the potential to greatly simplify the design and implementation of convergent data types in systems with weak messaging layer guarantees and a potentially large number of replicas.},
  type = {Whitepaper},
  date = {2019-05},
  author = {Sanjuan, Hector and Poyhtari, Samuli and Teixeira, Pedro},
  file = {/Users/carsonfarmer/Zotero/storage/9BNCRFTG/Sanjuan et al. - 1Protocol Labs 2Haja Networks.pdf}
}

@book{mortContentBasedAddressing2012,
  langid = {english},
  title = {Content {{Based Addressing}} : {{The}} Case for Multiple {{Internet}} Service Providers},
  url = {http://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-107174},
  shorttitle = {Content {{Based Addressing}}},
  abstract = {DiVA portal is a finding tool for research publications and student theses written at the following 49 universities and research institutions.},
  urldate = {2019-09-19},
  date = {2012},
  author = {Mört, Robert},
  file = {/Users/carsonfarmer/Zotero/storage/U588DNK4/Mört - 2012 - Content Based Addressing  The case for multiple I.pdf;/Users/carsonfarmer/Zotero/storage/7TYXHMAT/record.html}
}

@book{shapiroInformationRulesStrategic1998,
  title = {Information Rules: A Strategic Guide to the Network Economy},
  shorttitle = {Information Rules},
  publisher = {{Harvard Business Press}},
  date = {1998},
  author = {Shapiro, Carl and Carl, Shapiro and Varian, Hal R.},
  file = {/Users/carsonfarmer/Zotero/storage/GACGI67Q/Shapiro et al. - 1998 - Information rules a strategic guide to the networ.pdf;/Users/carsonfarmer/Zotero/storage/4QP5T68F/books.html}
}

@unpublished{markroberthendersonOrbitDBFieldManual2019,
  location = {{Haja Networks Oy}},
  title = {The {{OrbitDB Field Manual}}},
  url = {https://github.com/orbitdb/field-manual},
  abstract = {The Offical User's Guide to OrbitDB. Contribute to orbitdb/field-manual development by creating an account on GitHub.},
  type = {Guide},
  urldate = {2019-09-26},
  date = {2019-09-26},
  keywords = {decentralized,distributed,distributed-database,ipfs,orbit-db,p2p,peer-to-peer,reference,tutorial},
  author = {{Mark Robert Henderson} and {Samuli Pöyhtäri} and {Vesa-Ville Piiroinen} and {Juuso Räsänen} and {Shams Methnani} and {Richard Littauer}},
  origdate = {2019-01-14T20:20:00Z}
}

@online{ereminReduxInspiredBackend2019,
  langid = {english},
  title = {A {{Redux}}-{{Inspired Backend}}},
  url = {https://medium.com/resolvejs/resolve-redux-backend-ebcfc79bbbea},
  abstract = {Extending React+Redux ideas to the backend: Event Sourcing and CQRS.},
  journaltitle = {Medium},
  urldate = {2019-09-24},
  date = {2019-01-14},
  author = {Eremin, Roman},
  file = {/Users/carsonfarmer/Zotero/storage/BJKPT594/resolve-redux-backend-ebcfc79bbbea.html}
}

@online{abramovCaseFlux2015,
  langid = {english},
  title = {The {{Case}} for {{Flux}}},
  url = {https://medium.com/swlh/the-case-for-flux-379b7d1982c6},
  abstract = {Friends don’t let friends pick a design pattern blindly.},
  journaltitle = {Medium},
  urldate = {2019-09-23},
  date = {2015-11-03},
  author = {Abramov, Dan},
  file = {/Users/carsonfarmer/Zotero/storage/HLPVXW8E/the-case-for-flux-379b7d1982c6.html}
}

@article{haerderPrinciplesTransactionorientedDatabase1983,
  title = {Principles of {{Transaction}}-Oriented {{Database Recovery}}},
  volume = {15},
  issn = {0360-0300},
  doi = {10.1145/289.291},
  number = {4},
  journaltitle = {ACM Comput. Surv.},
  date = {1983-12},
  pages = {287--317},
  author = {Haerder, Theo and Reuter, Andreas}
}

@book{evansDomaindrivenDesignTackling2004a,
  title = {Domain-Driven Design: Tackling Complexity in the Heart of Software},
  shorttitle = {Domain-Driven Design},
  publisher = {{Addison-Wesley Professional}},
  date = {2004},
  author = {Evans, Eric},
  file = {/Users/carsonfarmer/Zotero/storage/DWLUV9PT/Evans - 2004 - Domain-driven design tackling complexity in the h.pdf;/Users/carsonfarmer/Zotero/storage/W5BPAXDP/books.html}
}

@online{facebookFluxInDepthOverview2019,
  langid = {english},
  title = {Flux: {{In}}-{{Depth Overview}}},
  url = {http://facebook.github.io/flux/docs/in-depth-overview},
  abstract = {Flux is the application architecture that Facebook uses for building client-side web applications. It complements React's composable view components by utilizing a unidirectional data flow. It's more of a pattern rather than a formal framework, and you can start using Flux immediately without a lot of new code.},
  urldate = {2019-09-23},
  date = {2019},
  author = {{Facebook}},
  file = {/Users/carsonfarmer/Zotero/storage/BLHQ4HBX/in-depth-overview.html}
}

@article{benetIPFSContentAddressed2014,
  title = {{{IPFS}}: {{Content}} Addressed, Versioned, P2p File System},
  volume = {(Draft 3)},
  journaltitle = {arXiv preprint arXiv:1407.3561},
  date = {2014},
  author = {Benet, Juan},
  file = {/Users/carsonfarmer/Zotero/storage/F4HVMIXM/Benet - 2014 - Ipfs-content addressed, versioned, p2p file system.pdf;/Users/carsonfarmer/Zotero/storage/NF985QYR/1407.html}
}

@unpublished{protocollabsFilecoinDecentralizedStorage2017,
  title = {Filecoin: {{A Decentralized Storage Network}}},
  abstract = {The internet is in the middle of a revolution: centralized proprietary services are being replaced with
decentralized open ones; trusted parties replaced with verifiable computation; brittle location addresses
replaced with resilient content addresses; inefficient monolithic services replaced with peer-to-peer algorithmic markets. Bitcoin, Ethereum, and other blockchain networks have proven the utility of decentralized transaction ledgers. These public ledgers process sophisticated smart contract applications and
transact crypto-assets worth tens of billions of dollars. These systems are the first instances of internetwide Open Services, where participants form a decentralized network providing useful services for pay,
with no central management or trusted parties. IPFS has proven the utility of content-addressing by
decentralizing the web itself, serving billions of files used across a global peer-to-peer network. It liberates data from silos, survives network partitions, works offline, routes around censorship, and gives
permanence to digital information.
Filecoin is a decentralized storage network that turns cloud storage into an algorithmic market. The
market runs on a blockchain with a native protocol token (also called “Filecoin”), which miners earn
by providing storage to clients. Conversely, clients spend Filecoin hiring miners to store or distribute
data. As with Bitcoin, Filecoin miners compete to mine blocks with sizable rewards, but Filecoin mining
power is proportional to active storage, which directly provides a useful service to clients (unlike Bitcoin
mining, whose usefulness is limited to maintaining blockchain consensus). This creates a powerful incentive for miners to amass as much storage as they can, and rent it out to clients. The protocol weaves
these amassed resources into a self-healing storage network that anybody in the world can rely on. The
network achieves robustness by replicating and dispersing content, while automatically detecting and
repairing replica failures. Clients can select replication parameters to protect against different threat
models. The protocol’s cloud storage network also provides security, as content is encrypted end-to-end
at the client, while storage providers do not have access to decryption keys. Filecoin works as an incentive
layer on top of IPFS [1], which can provide storage infrastructure for any data. It is especially useful
for decentralizing data, building and running distributed applications, and implementing smart contracts},
  type = {Whitepaper},
  date = {2017-07-19},
  author = {{Protocol Labs}},
  file = {/Users/carsonfarmer/Zotero/storage/3YGBY2LR/filecoin.pdf}
}

@online{berners-leeLinkedData2009,
  title = {Linked {{Data}}},
  url = {https://www.w3.org/DesignIssues/LinkedData.html},
  journaltitle = {Design Issues},
  urldate = {2019-09-20},
  date = {2009-06-18},
  author = {Berners-Lee, Tim},
  file = {/Users/carsonfarmer/Zotero/storage/MJP3TZI2/LinkedData.html}
}

@incollection{bizerLinkedDataStory2011,
  title = {Linked Data: {{The}} Story so Far},
  shorttitle = {Linked Data},
  booktitle = {Semantic Services, Interoperability and Web Applications: Emerging Concepts},
  publisher = {{IGI Global}},
  date = {2011},
  pages = {205--227},
  author = {Bizer, Christian and Heath, Tom and Berners-Lee, Tim},
  file = {/Users/carsonfarmer/Zotero/storage/MK7QHECR/Bizer et al. - 2011 - Linked data The story so far.pdf;/Users/carsonfarmer/Zotero/storage/ASJK9F3V/55046.html}
}

@article{heathLinkedDataEvolving2011,
  title = {Linked {{Data}}: {{Evolving}} the {{Web}} into a {{Global Data Space}}},
  volume = {1},
  issn = {2160-4711},
  doi = {10.2200/S00334ED1V01Y201102WBE001},
  shorttitle = {Linked {{Data}}},
  number = {1},
  journaltitle = {Synthesis Lectures on the Semantic Web: Theory and Technology},
  shortjournal = {Synthesis Lectures on the Semantic Web: Theory and Technology},
  date = {2011-02-09},
  pages = {1-136},
  author = {Heath, Tom and Bizer, Christian},
  file = {/Users/carsonfarmer/Zotero/storage/8H4RBUPY/S00334ED1V01Y201102WBE001.html}
}

@unpublished{brendanobrienDeterministicQueryingDistributed2017,
  title = {Deterministic {{Querying}} for the {{Distributed Web}}},
  url = {https://qri.io/papers/deterministic_querying/},
  abstract = {The current infrastructure that underlies the distribution and processing of data over the Internet has enabled dramatic advances in a wide variety of human activities. Recent trends promoting open data promise even greater benefits as the number and variety of networked datasets grow. However, while current technologies and architectures obviously do work, they also show signs of systemic inefficiencies that impede effective large-scale discovery, distribution, preservation and reuse of datasets. An important source of inefficiency is rooted in the database-centric architecture that underlies much of data processing on the Internet today. The transition to a content-addressed permanent web offers an opportunity to replace certain software architecture patterns with alternatives that are more efficient and scale more effectively. We introduce one such new pattern, deterministic querying, that combines formalized query definitions, formalized data descriptions, linked metadata, hashing, and a content-addressed file system. The result supports database-free reuse of data and data processing results—and can do so on the scale of the global Internet.},
  type = {Whitepaper},
  date = {2017-11},
  author = {{Brendan O’Brien} and {Michael Hucka}}
}

@online{srisureshIPNetworkAddress,
  langid = {english},
  title = {{{IP Network Address Translator}} ({{NAT}}) {{Terminology}} and {{Considerations}}},
  url = {https://tools.ietf.org/html/rfc2663},
  urldate = {2019-09-20},
  author = {Srisuresh, Pyda and Holdrege, Matt},
  file = {/Users/carsonfarmer/Zotero/storage/G9SV5TGA/rfc2663.html}
}

@online{protocollabsMultihash,
  langid = {english},
  title = {Multihash},
  url = {https://multiformats.io/},
  abstract = {Self-describing values for Future-proofing},
  journaltitle = {Multiformats},
  type = {Docs},
  urldate = {2019-09-27},
  author = {{Protocol Labs}},
  file = {/Users/carsonfarmer/Zotero/storage/KBMP6295/multihash.html}
}

@online{protocollabsMultiaddr,
  langid = {english},
  title = {Multiaddr},
  url = {https://multiformats.io/},
  abstract = {Self-describing values for Future-proofing},
  journaltitle = {Multiformats},
  urldate = {2019-09-20},
  author = {{Protocol Labs}},
  file = {/Users/carsonfarmer/Zotero/storage/6CAHEHYS/multiaddr.html}
}

@online{reduxMotivation,
  langid = {english},
  title = {Motivation},
  url = {https://redux.js.org/introduction/motivation},
  abstract = {\# Motivation},
  journaltitle = {Redux},
  urldate = {2019-09-20},
  author = {{Redux}},
  file = {/Users/carsonfarmer/Zotero/storage/HJX25AFC/motivation.html}
}

@online{securescuttlebuttScuttlebuttProtocolGuide,
  title = {Scuttlebutt {{Protocol Guide}}},
  url = {https://ssbc.github.io/scuttlebutt-protocol-guide/},
  abstract = {Scuttlebutt is a protocol for building decentralized applications that work well offline and that no one person can control. Because there is no central server, Scuttlebutt clients connect to their peers to exchange information. This guide describes the protocols used to communicate within the Scuttlebutt network.},
  urldate = {2019-09-11},
  author = {{Secure Scuttlebutt}},
  file = {/Users/carsonfarmer/Zotero/storage/EI95BF8C/scuttlebutt-protocol-guide.html}
}

@unpublished{ericharris-braunHolochainScalableAgentcentric2018,
  location = {{Ceptr LLC}},
  title = {Holochain: Scalable Agent-Centric Distributed Computing},
  url = {https://holo.host/whitepapers/},
  abstract = {We present a scalable, agent-centric distributed computing platform. We use a
formalism to characterize distributed systems, show how it applies to some existing distributed
systems, and demonstrate the benefits of shifting from a data-centric to an agent-centric model.
We present a detailed formal specification of the Holochain system, along with an analysis of its
systemic integrity, capacity for evolution, total system computational complexity, implications for
use-cases, and current implementation status.},
  pagetotal = {14},
  type = {Whitepaper},
  date = {2018-02-15},
  author = {{Eric Harris-Braun} and {Nicolas Luck} and {Arthur Brock}}
}

@online{shireyInternetSecurityGlossary2007,
  langid = {english},
  title = {Internet {{Security Glossary}}, {{Version}} 2},
  url = {https://tools.ietf.org/html/rfc4949},
  abstract = {This Glossary provides definitions, abbreviations, and explanations
   of terminology for information system security. The 334 pages of
   entries offer recommendations to improve the comprehensibility of
   written material that is generated in the Internet Standards Process
   (RFC 2026). The recommendations follow the principles that such
   writing should (a) use the same term or definition whenever the same
   concept is mentioned; (b) use terms in their plainest, dictionary
   sense; (c) use terms that are already well-established in open
   publications; and (d) avoid terms that either favor a particular
   vendor or favor a particular technology or mechanism over other,
   competing techniques that already exist or could be developed.},
  journaltitle = {Network Working Group},
  type = {RFC},
  urldate = {2019-09-20},
  date = {2007-08},
  author = {Shirey, Robert W.},
  file = {/Users/carsonfarmer/Zotero/storage/Y63ESPWV/rfc4949.html}
}

@inproceedings{herzbergAccessControlMeets2000,
  title = {Access Control Meets Public Key Infrastructure, or: Assigning Roles to Strangers},
  doi = {10.1109/SECPRI.2000.848442},
  shorttitle = {Access Control Meets Public Key Infrastructure, Or},
  abstract = {The Internet enables connectivity between many strangers: entities that don't know each other. We present the Trust Policy Language (TPL), used to define the mapping of strangers to predefined business roles, based on certificates issued by third parties. TPL is expressive enough to allow complex policies, e.g. non-monotone (negative) certificates, while being simple enough to allow automated policy checking and processing. Issuers of certificates are either known in advance, or provide sufficient certificates to be considered a trusted authority according to the policy. This allows bottom-up, "grass roots" buildup of trust, as in the real world. We extend, rather than replace, existing role based access control mechanisms. This provides a simple, modular architecture and easy migration from existing systems. Our system automatically collects missing certificates from peer servers. In particular this allows use of standard browsers, which pass only one certificate to the server. We describe our implementation, which can be used as an extension of a Web server or as a separate server with interface to applications.},
  eventtitle = {Proceeding 2000 {{IEEE Symposium}} on {{Security}} and {{Privacy}}. {{S P}} 2000},
  booktitle = {Proceeding 2000 {{IEEE Symposium}} on {{Security}} and {{Privacy}}. {{S P}} 2000},
  date = {2000-05},
  pages = {2-14},
  keywords = {Access control,Authentication,authorisation,automated policy checking,Business,certificates,Certification,complex policies,Electronic commerce,file servers,Internet,Logic programming,message authentication,missing certificates,modular architecture,non-monotone certificates,peer servers,Permission,predefined business roles,Public key,public key cryptography,public key infrastructure,role assignment,role based access control mechanisms,standard browsers,stranger connectivity,third parties,TPL,Trust Policy Language,trusted authority,Web server},
  author = {Herzberg, A. and Mass, Y. and Mihaeli, J. and Naor, D. and Ravid, Y.},
  file = {/Users/carsonfarmer/Zotero/storage/CSRFUE4R/848442.html}
}

@inproceedings{enesSingleWriterPrincipleCRDT2017,
  langid = {english},
  location = {{Barcelona, Spain}},
  title = {The {{Single}}-{{Writer Principle}} in {{CRDT Composition}}},
  isbn = {978-1-4503-6356-3},
  doi = {10.1145/3166089.3168733},
  eventtitle = {The {{Programming Models}} and {{Languages}} for {{Distributed Computing}}},
  booktitle = {Proceedings of the {{Programming Models}} and {{Languages}} for {{Distributed Computing}} on   - {{PMLDC}} '17},
  publisher = {{ACM Press}},
  date = {2017},
  pages = {1-3},
  author = {Enes, Vitor and Almeida, Paulo Sérgio and Baquero, Carlos},
  file = {/Users/carsonfarmer/Zotero/storage/9DLV6DXT/Enes et al. - 2017 - The Single-Writer Principle in CRDT Composition.pdf}
}

@inproceedings{selimi_tahoeLafs_2014,
	title = {Tahoe-{LAFS} {Distributed} {Storage} {Service} in {Community} {Network} {Clouds}},
	doi = {10.1109/BDCloud.2014.24},
	abstract = {Community networks are successful large scale, decentralized IP networks, built and operated by citizens for citizens. Cloud computing infrastructures present in today's Internet hardly exist in community networks. But the demand for cloud storage, and in particular secure cloud storage, increases also from within the communities. We deploy in community networks Tahoe-LAFS, a decentralized storage system with provider-independent security that guarantees privacy to the users. The correct functionality of Tahoe-LAFS in the community network is our first performance evaluation goal. Secondly, acceptable user experience is needed in order to make users willing to join the cloud, to create an eco-system around this cloud storage service. Our approach for the performance evaluation is to reproduce in our experimental scenario the real use case. We evaluate how the Tahoe-LAFS storage system performs when it is deployed over a WAN setting on cloud nodes in a community network. In experiments we characterize with different file sizes the upload and download times of Tahoe-LAFS, in relation to the bandwidth and latency between the client and the storage nodes. While we observe higher upload and faster download times, Tahoe-LAFS performed correctly in the challenging environment of the community network. Our results suggest Tahoe-LAFS as a promising application for privacy-preserving, secure and fault-tolerant cloud-based storage services in community networks.},
	booktitle = {2014 {IEEE} {Fourth} {International} {Conference} on {Big} {Data} and {Cloud} {Computing}},
	author = {Selimi, M. and Freitag, F.},
	month = dec,
	year = {2014},
	keywords = {cloud computing, Cloud computing, cloud storage, cloud storage service, Clouds, Communities, community cloud, community network clouds, community networks, Cryptography, decentralized IP networks, decentralized storage system, distributed processing, fault tolerance, fault tolerant cloud computing, Hardware, Internet, Peer-to-peer computing, privacy-preserving application, Tahoe LAFS distributed storage service, Wireless communication},
	pages = {17--24},
	file = {IEEE Xplore Abstract Record:/Users/andrewhill/Zotero/storage/ZM7VT6YK/7034761.html:text/html}
}

@inproceedings{rhea_fast_2008,
	title = {Fast, {Inexpensive} {Content}-{Addressed} {Storage} in {Foundation}.},
	booktitle = {{USENIX} {Annual} {Technical} {Conference}},
	author = {Rhea, Sean C. and Cox, Russ and Pesterev, Alex},
	year = {2008},
	pages = {143--156},
	file = {Full Text:/Users/andrewhill/Zotero/storage/5RV8SHUU/Rhea et al. - 2008 - Fast, Inexpensive Content-Addressed Storage in Fou.pdf:application/pdf}
}

@online{meyerBamboo2019,
  title = {Bamboo},
  url = {https://github.com/AljoschaMeyer/bamboo},
  abstract = {A cryptographically secure, distributed, single-writer append-only log that supports transitive partial replication and local deletion of data.

Powered by science, this log format can serve as a more efficient alternative to secure-scuttlebutt's linked lists or hypercore's merkle forests.

Status: Well-defined and useful. Pending stabilization: If I don't see any need for further changes by 30/04/2020, this will be declared stable and any later breaking changes will result in new, non-bamboo specifications.},
  urldate = {2019-09-20},
  date = {2019-09-16T23:57:05Z},
  author = {Meyer, Aljoscha},
  origdate = {2019-03-28T22:51:48Z}
}

@online{leachUniversallyUniqueIDentifier2005,
  langid = {english},
  title = {A {{Universally Unique IDentifier}} ({{UUID}}) {{URN Namespace}}},
  url = {https://tools.ietf.org/html/rfc4122},
  abstract = {This specification defines a Uniform Resource Name namespace for
   UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally
   Unique IDentifier).  A UUID is 128 bits long, and can guarantee
   uniqueness across space and time.  UUIDs were originally used in the
   Apollo Network Computing System and later in the Open Software
   Foundation's (OSF) Distributed Computing Environment (DCE), and then
   in Microsoft Windows platforms.

   This specification is derived from the DCE specification with the
   kind permission of the OSF (now known as The Open Group).
   Information from earlier versions of the DCE specification have been
   incorporated into this document.},
  journaltitle = {Network Working Group},
  type = {RFC},
  urldate = {2019-09-20},
  date = {2005-07},
  author = {Leach, Paul J. and Mealling, Michael and Salz, Rich},
  file = {/Users/carsonfarmer/Zotero/storage/97B2LBPK/rfc4122.html}
}

@article{kleppmannConflictFreeReplicatedJSON2017,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1608.03960},
  title = {A {{Conflict}}-{{Free Replicated JSON Datatype}}},
  volume = {28},
  issn = {1045-9219},
  doi = {10.1109/TPDS.2017.2697382},
  abstract = {Many applications model their data in a general-purpose storage format such as JSON. This data structure is modified by the application as a result of user input. Such modifications are well understood if performed sequentially on a single copy of the data, but if the data is replicated and modified concurrently on multiple devices, it is unclear what the semantics should be. In this paper we present an algorithm and formal semantics for a JSON data structure that automatically resolves concurrent modifications such that no updates are lost, and such that all replicas converge towards the same state (a conflict-free replicated datatype or CRDT). It supports arbitrarily nested list and map types, which can be modified by insertion, deletion and assignment. The algorithm performs all merging client-side and does not depend on ordering guarantees from the network, making it suitable for deployment on mobile devices with poor network connectivity, in peer-to-peer networks, and in messaging systems with end-to-end encryption.},
  number = {10},
  journaltitle = {IEEE Transactions on Parallel and Distributed Systems},
  shortjournal = {IEEE Trans. Parallel Distrib. Syst.},
  date = {2017-10-01},
  pages = {2733-2746},
  keywords = {Computer Science - Databases,Computer Science - Distributed; Parallel; and Cluster Computing},
  author = {Kleppmann, Martin and Beresford, Alastair R.},
  file = {/Users/carsonfarmer/Zotero/storage/Z86B9ZWX/Kleppmann and Beresford - 2017 - A Conflict-Free Replicated JSON Datatype.pdf;/Users/carsonfarmer/Zotero/storage/IM3VTZDR/1608.html}
}

@online{reduxMotivation,
  langid = {english},
  title = {Motivation},
  url = {https://redux.js.org/introduction/motivation},
  abstract = {\# Motivation},
  journaltitle = {Redux},
  urldate = {2019-09-20},
  author = {{Redux}},
  file = {/Users/carsonfarmer/Zotero/storage/HJX25AFC/motivation.html}
}

@article{sandhuRolebasedAccessControl1996,
  title = {Role-Based Access Control Models},
  volume = {29},
  doi = {10.1109/2.485845},
  abstract = {Security administration of large systems is complex, but it can be simplified by a role-based access control approach. This article explains why RBAC is receiving renewed attention as a method of security administration and review, describes a framework of four reference models developed to better understand RBAC and categorizes different implementations, and discusses the use of RBAC to manage itself.},
  number = {2},
  journaltitle = {Computer},
  date = {1996-02},
  pages = {38-47},
  keywords = {Access control,authorisation,Authorization,data security,Data security,Government,large systems,NIST,Permission,Privacy,RBAC,reference models,Resource management,role-based access control,security administration,security of data,Software systems,Telephony},
  author = {Sandhu, R. S. and Coyne, E. J. and Feinstein, H. L. and Youman, C. E.},
  file = {/Users/carsonfarmer/Zotero/storage/YNGGD3K3/485845.html}
}

@online{hashicorpKeyRotation,
  langid = {english},
  title = {Key {{Rotation}}},
  url = {https://www.vaultproject.io/docs/internals/rotation.html},
  abstract = {Learn about the details of key rotation within Vault.},
  urldate = {2019-09-20},
  author = {{HashiCorp}},
  file = {/Users/carsonfarmer/Zotero/storage/E823Q9BZ/rotation.html}
}

@misc{rfc7396,
	series =	{Request for Comments},
	number =	7396,
	howpublished =	{RFC 7396},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC7396},
	url =		{https://rfc-editor.org/rfc/rfc7396.txt},
        author =	{James M. Snell and Paul E. Hoffman},
	title =		{{JSON Merge Patch}},
	pagetotal =	9,
	year =		2014,
	month =		oct,
	abstract =	{This specification defines the JSON merge patch format and processing rules. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content.},
}

@misc{rfc6902,
	series =	{Request for Comments},
	number =	6902,
	howpublished =	{RFC 6902},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC6902},
	url =		{https://rfc-editor.org/rfc/rfc6902.txt},
        author =	{Paul C. Bryan and Mark Nottingham},
	title =		{{JavaScript Object Notation (JSON) Patch}},
	pagetotal =	18,
	year =		2013,
	month =		apr,
	abstract =	{JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method. The "application/json-patch+json" media type is used to identify such patch documents.},
}

@misc{dep0008,
	series =	{Dat Enhancement Proposals},
	number =	0008,
	howpublished =	{0008-multiwriter},
	publisher =	{Dat Protocol},
	url =		{https://www.datprotocol.com/deps/0008-multiwriter/},
  author =	{Bryan Newbold and Stephen Whitmore and Mathias Buus},
	title =		{{DEP-0008: Multi-Writer}},
	year =		2018,
	month =		jul,
	abstract =	{Multi-Writer is a set of schema, API, and feature extensions to allow multiple agents (users, devices, or software) to write to the same hyperdb database. By building on top of this abstraction layer, future versions of hyperdrive and Dat will gain these features. Mechanisms for distributed consistency and granting trust are specified here; the need for merge conflict algorithms and secure key distribution are mentioned but specific solutions are not specified. This DEP forms the second half of the hyperdb specification; the first half covered only the key/value database aspects of hyperdb.},
}

@misc{dep0004,
	series =	{Dat Enhancement Proposals},
	number =	0008,
	howpublished =	{0008-hyperdb},
	publisher =	{Dat Protocol},
	url =		{https://www.datprotocol.com/deps/0008-hyperdb/},
  author =	{Bryan Newbold and Stephen Whitmore and Mathias Buus},
	title =		{{DEP-0004: Hyperdb}},
	year =		2018,
	month =		may,
	abstract =	{Hyperdb is an abstraction layer providing a general purpose distributed key/value store over the hypercore protocol. It is an iteration on the hyperdrive directory tree implementation, building on top of the hypercore append-only log abstraction layer. Keys are path-like strings (e.g., /food/fruit/kiwi), and values are arbitrary binary blobs (generally under a megabyte). Hyperdrive (used by the Dat application) is expected to be re-implemented on top of hyperdb for improved performance with many files (e.g., millions). The hyperdrive API should be largely unchanged, but the metadata format will be backwards-incompatible.},
}

@misc{dep0002,
	series =	{Dat Enhancement Proposals},
	number =	0002,
	howpublished =	{0002-hypercore},
	publisher =	{Dat Protocol},
	url =		{https://www.datprotocol.com/deps/0002-hypercore/},
  author =	{Paul Frazee and Mathias Buus},
	title =		{{DEP-0002: Hypercore}},
	year =		2018,
	month =		feb,
	abstract =	{Hypercore Feeds are the core mechanism used in Dat. They are binary append-only streams whose contents are cryptographically hashed and signed and therefore can be verified by anyone with access to the public key of the writer. Dat uses two feeds, content and metadata. The content feed contains the files in your repository and metadata contains the metadata about the files including name, size, last modified time, etc. Dat replicates them both when synchronizing with another peer.},
}

@techreport{handrews-json-schema-02,
	number =	{draft-handrews-json-schema-02},
	type =		{Internet-Draft},
	institution =	{Internet Engineering Task Force},
	publisher =	{Internet Engineering Task Force},
	note =		{Work in Progress},
	url =		{https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-02},
        author =	{Austin Wright and Henry Andrews and Ben Hutton and Greg Dennis},
	title =		{{JSON Schema: A Media Type for Describing JSON Documents}},
	pagetotal =	75,
	year =		2019,
	month =		sep,
	day =		17,
	abstract =	{JSON Schema defines the media type "application/schema+json", a JSON- based format for describing the structure of JSON data. JSON Schema asserts what a JSON document must look like, ways to extract information from it, and how to interact with it. The "application/ schema-instance+json" media type provides additional feature-rich integration with "application/schema+json" beyond what can be offered for "application/json" documents.},
}

@article{marlinspikeDoubleRatchetAlgorithm2016,
  langid = {english},
  title = {The {{Double Ratchet Algorithm}}},
  volume = {Revision 1},
  url = {https://signal.org/docs/specifications/doubleratchet},
  abstract = {The Double Ratchet algorithm is used by two parties to exchange encrypted messages based on a shared secret key. Typically the parties will use some key agreement protocol (such as X3DH [1]) to agree on the shared secret key. Following this, the parties will use the Double Ratchet to send and receive encrypted messages.

The parties derive new keys for every Double Ratchet message so that earlier keys cannot be calculated from later ones. The parties also send Diffie-Hellman public values attached to their messages. The results of Diffie-Hellman calculations are mixed into the derived keys so that later keys cannot be calculated from earlier ones. These properties gives some protection to earlier or later encrypted messages in case of a compromise of a party's keys.

The Double Ratchet and its header encryption variant are presented below, and their security properties are discussed.},
  date = {2016-11-20},
  pages = {35},
  author = {Marlinspike, Moxie},
  editor = {Perrin, Trevor},
  file = {/Users/carsonfarmer/Zotero/storage/GU3IK7ZZ/Perrin - The Double Ratchet Algorithm.pdf}
}

@inproceedings{ungerSoKSecureMessaging2015,
  title = {{{SoK}}: {{Secure Messaging}}},
  doi = {10.1109/SP.2015.22},
  shorttitle = {{{SoK}}},
  abstract = {Motivated by recent revelations of widespread state surveillance of personal communication, many solutions now claim to offer secure and private messaging. This includes both a large number of new projects and many widely adopted tools that have added security features. The intense pressure in the past two years to deliver solutions quickly has resulted in varying threat models, incomplete objectives, dubious security claims, and a lack of broad perspective on the existing cryptographic literature on secure communication. In this paper, we evaluate and systematize current secure messaging solutions and propose an evaluation framework for their security, usability, and ease-of-adoption properties. We consider solutions from academia, but also identify innovative and promising approaches used "in-the-wild" that are not considered by the academic literature. We identify three key challenges and map the design landscape for each: trust establishment, conversation security, and transport privacy. Trust establishment approaches offering strong security and privacy features perform poorly from a usability and adoption perspective, whereas some hybrid approaches that have not been well studied in the academic literature might provide better trade-offs in practice. In contrast, once trust is established, conversation security can be achieved without any user involvement in most two-party conversations, though conversations between larger groups still lack a good solution. Finally, transport privacy appears to be the most difficult problem to solve without paying significant performance penalties.},
  eventtitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  booktitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  date = {2015-05},
  pages = {232-249},
  keywords = {conversation security,cryptographic literature,cryptography,data privacy,Encryption,message passing,personal communication,Privacy,private messaging,Protocols,secure messaging,SoK,state surveillance,Synthetic aperture sonar,transport privacy,Usability},
  author = {Unger, N. and Dechand, S. and Bonneau, J. and Fahl, S. and Perl, H. and Goldberg, I. and Smith, M.},
  file = {/Users/carsonfarmer/Zotero/storage/KZ485EST/Unger et al. - 2015 - SoK Secure Messaging.pdf;/Users/carsonfarmer/Zotero/storage/LL8FGQZD/7163029.html}
}

@online{martinfowlerCQRS2011,
  title = {{{CQRS}}},
  url = {https://martinfowler.com/bliki/CQRS.html},
  shorttitle = {Bliki},
  abstract = {CQRS (Command Query Responsibility Segregation) is the notion that you can use a different model to update information than the model you use to read information},
  journaltitle = {martinfowler.com},
  urldate = {2019-09-20},
  date = {2011-07-14},
  author = {{Martin Fowler}},
  file = {/Users/carsonfarmer/Zotero/storage/AEB3YSQ2/CQRS.html}
}
